# Конфигурация сайта документации

Когда мы создавали [онлайн-документацию Docsvision](https://habr.com/ru/post/592477/) при помощи Antora, перед нами стояла задача оставить место, в которое в будущем будем интегрировать документацию накопительных изменений.

К релизу мы уже [подготовили сайт документации](https://habr.com/ru/company/docsvision/blog/693832/), оставалось время, которое мы решили потратить на интеграцию страницы накопительных изменений. Эта работа подарила нам интересный опыт внутрикомандного взаимодействия, которым я сегодня поделюсь. 

## На старт, внимание, патч!

Процесс выпуска продукта у нас построен так, что после релиза для продукта выпускаются исправления по запросу через техподдержку. От клиента приходит запрос на исправление, после чего разработчик правит код, делает коммит, оставляет в нём комментарий. Комментарий мы выбрали в качестве отправной точки.

Страница должна смотреться на сайте органично, а значит должна быть его частью. Сколько нужно айтишников, чтобы создать одну органично выглядящую страницу? Ровно трое: один техписатель, один инженер по конфигурации и один дизайнер.

Я пишу документацию в формате AsciiDoc, но страница будет формироваться автоматически без его помощи. Моя задача как технического писателя состояла в том, чтобы добавить страницу на сайт.

Сайт формируется при помощи Antora — генератора статических сайтов для AsciiDoc. Сборка как сайта, так и исправлений с накопительными изменениями у нас настроена через TeamCity, поэтому задача инженера по конфигурации — настроить TeamCity так, чтобы он поддерживал одновременно сборку исправлений, сборку сайта и передачу списка изменений в документацию.

Задача дизайнера состояла в том, чтобы создать страницу в том виде, в котором она будет на сайте. И чтобы на ней был свой поиск, шапка, навигация и группировка по категориям: функциональные изменения, ошибка, оптимизация, примеры на GitHub.

## Встроить, но не смешивать — задача для техписателя

Поставленная задача может быть разбита на две составляющие:

- Добавить страницу на сайт
- Сделать её максимально нейтральной

![Страница в навигации](img/page-in-nav.png)

Задача ясна, добавляю пустую страницу, а в неё один атрибут и заголовок:

```asciidoc
:page-layout: patches

= Накопительные обновления
```

Простая задача на поверхности, а под капотом... Во-первых, атрибут указывает Анторе, что нужно использовать специальный шаблон страницы. Шаблон сам не появится, его нужно создать.

За основу я взял шаблон стандартной страницы из репозитория [пользовательского интерфейса](https://github.com/Docsvision/antora-ui-default) Antora. Получился вот такой специальный шаблон:

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
{{> head-patches defaultPageTitle='Untitled'}}
  </head>
  <body class="article{{#with (or page.attributes.role page.role)}} {{{this}}}{{/with}}">
{{> header}}
{{> body-patches}}
{{> footer}}
  </body>
</html>
```

В `<head>` этой страницы я добавил новые строки, которые в будущем будут подключать специальный стиль:

```html
<link rel="stylesheet" href="{{{uiRootPath}}}/css/vendor/patches.min.css">
```

Я также добавил JavaScript, который призван обращаться к базе за списком накопительных изменений и добавлять их на страницу:

```html
<script type="module" crossorigin src="{{uiRootPath}}/js/vendor/patches.min.js"></script>
```

## Вперёд на фронт!

![Поиск](img/search.png)

Файл стилей `patches.min.css` и рабочий скрипт `patches.min.js` создал наш дизайнер.

Задача для дизайнера была поставлена следующим образом:

- Применить сквозной поиск по всем изменениям
- Страница должна иметь дружелюбный интерфейс
- Создать на странице понятную и удобную древовидную структуру

Разумеется, решить задачи необходимо в сжатые сроки. 

Сквозной поиск был реализован благодаря Vue 3 для создания и вывода HTML на страницу. Фреймворк позволил использовать поиск по странице из браузера, без запросов на сервер.

Дружелюбный интерфейс дизайнер реализовал с помощью Quasar. Распахивающиеся панели, поля ввода, кнопки, иконки и другие готовые Vue-компоненты также позволили решить задачу в сжатые сроки.

Сложнее всего было создать древовидную структуру, преобразовав данные, полученные с сервера. С сервера приходит плоский список, который на странице должен быть сгруппирован по релизам и типам исправлений. С помощью TypeScript данные преобразовываются в массив релизов, каждый из которых состоит из дочерних массивов. В этих массивах и находятся ошибки, оптимизации, функциональные и другие изменения. 

Собрать проект помог сборщик Vite.js.

В рамках этой задачи получившийся код приходилось примерять несколько раз, чтобы один убрать лишние строки в скрипте или удалить конфликтующие стили. Отдельным видом развлечения была игра в детективов, чтобы выявить мешающие строки.

![Древовидная структура](img/page.png)

## К слову о сервере

Накопительные изменения хранятся в базе данных, а из неё попадают на страницу сайта из базы данных и формируют страницу похожую на страницу документации.

![Список изменений](img/tasks.png)

В БД изменения попадают, когда разработчик запускает коммитом сборку продукта. TeamCity отправляет POST запрос, в теле которого передается идентификатор сборки продукта, идентификатор продукта, версия и массив вошедших изменений. Эти изменения позже попадут в контейнерный сервис и в БД.

Пример информации от TeamCity:

```json
{
  "Id": 117188,
  "ProductId": 1,
  "FileVersion": "5.5.5957.327",
  "Changes": [
    {
      "Title": "ERR-2471",
      "Description": "Диалог атрибутивного поиска. Заменить кебаб на крестик",
      "Type": 1
    },
  ]
}
```

![Страница с адресом редактора](img/service-url.png)

[//]: # (Не всегда получается что-то исправить с первого раза, в истории изменений один и тот же номер YouTrack может встречаться несколько раз и входить в разные сборки. Когда TeamCity делает POST запрос, происходит проверка, не было ли это исправлено в предыдущих сборках этого продукта. Если было, у предыдущих записей меняется тип на Заметка &#40;0&#41;, а Исправление &#40;1&#41; остаётся только у последнего.)

## Что написано пером, то можно изменить в редакторе

Сервис хранит информацию в БД SQLite. Информация в БД не высечена из камня и может быть отредактирована через специальный редактор. Ссылка на редактор появляется после успешной сборки продукта.

![Окно редактора](img/editor.png)

Редактор позволяет выбрать тип изменения, отредактировать описание или перенести изменение в заметки, чтобы оно носило чисто информативный характер и не отображалось на сайте.

Если сборка была опубликована на портале технической поддержки, сервис включит в неё изменения предыдущих сборок, которые не были опубликованы на портале.

## Цепочка сборки

![Цепочка сборки](img/chain.png)

Цепочка сборки документации состоит из 5 конфигураций:

- **Composite** — запускает цепочку сборки, проверяет изменения в репозиториях документации.
- **Patches** — собирает стили и скрипты для страницы со списком накопительных изменений.
- **UI bundle** — собирает пользовательский интерфейс сайта, забирает ресурсы из **Patches**.
- **Playbook** — собирает сайт, используя **Patches** и **UI bundle**.
- **Deployment** — обновляет сайт, заменяет контейнер с nginx, в котором он лежит.

При запуске проверяются изменения в предыдущих конфигурациях цепи, если какую-то конфигурацию можно не собирать повторно, она собрана не будет.

## Заключение

Таким образом на сайте появляется самая свежая документация, которая включает основной раздел и раздел с описанием накопительных изменений. Если возникнет потребность что-то изменить в сайте или документации, то изменения появятся на сайте в течение 10 минут после коммита.

Опыт сотрудничество технического писателя, дизайнера и инженера по конфигурации в рамках одной задачи — определённо весомый вклад в усиление командного взаимодействия.
